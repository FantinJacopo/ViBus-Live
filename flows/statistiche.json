[
    {
        "id": "stats_tab",
        "type": "tab",
        "label": "ViBus Statistics Real-Time",
        "disabled": false,
        "info": "Calcolo statistiche in tempo reale da dati autobus"
    },
    {
        "id": "inject_stats_timer",
        "type": "inject",
        "z": "stats_tab",
        "name": "Timer Statistiche (30s)",
        "props": [{"p": "payload"}],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 100,
        "wires": [["calc_line_stats", "calc_system_stats"]]
    },
    {
        "id": "calc_line_stats",
        "type": "function",
        "z": "stats_tab",
        "name": "Calcola Statistiche Linee",
        "func": "const lines = [\"1\", \"2\", \"3\", \"5\", \"7\"];\nconst now = new Date();\nconst allBuses = flow.get(\"buses\") || [];\n\nif (allBuses.length === 0) {\n    node.warn(\"Nessun dato autobus disponibile per calcolare statistiche\");\n    return null;\n}\n\nconst statistiche = [];\n\nlines.forEach(lineId => {\n    const busesLinea = allBuses.filter(bus => bus.line === lineId);\n    \n    if (busesLinea.length > 0) {\n        const velocitaMedia = busesLinea.reduce((sum, bus) => sum + bus.speed, 0) / busesLinea.length;\n        const ritardoMedio = busesLinea.reduce((sum, bus) => sum + bus.delay, 0) / busesLinea.length;\n        const ritardoMassimo = Math.max(...busesLinea.map(bus => bus.delay));\n        const passeggeriTotali = busesLinea.reduce((sum, bus) => sum + bus.passengers, 0);\n        \n        const autobusInOrario = busesLinea.filter(bus => bus.delay <= 2).length;\n        const percentualePuntualita = (autobusInOrario / busesLinea.length) * 100;\n        \n        const stats = {\n            line: lineId,\n            line_name: getLineName(lineId),\n            active_buses: busesLinea.length,\n            average_speed: Math.round(velocitaMedia * 10) / 10,\n            average_delay: Math.round(ritardoMedio * 10) / 10,\n            max_delay: Math.round(ritardoMassimo * 10) / 10,\n            on_time_percentage: Math.round(percentualePuntualita * 10) / 10,\n            total_passengers: passeggeriTotali,\n            day_type: now.getDay() === 0 || now.getDay() === 6 ? 'weekend' : 'weekday',\n            timestamp: now.toISOString()\n        };\n        \n        statistiche.push({\n            topic: `vibus/linea/${lineId}/statistiche`,\n            payload: JSON.stringify(stats)\n        });\n        \n        node.log(`Statistiche Linea ${lineId}: ${busesLinea.length} autobus, ritardo medio ${ritardoMedio.toFixed(1)}min`);\n    }\n});\n\nfunction getLineName(lineId) {\n    const nomi = {\n        \"1\": \"Stanga-Ospedale\",\n        \"2\": \"Anconetta-Ferrovieri\", \n        \"3\": \"Maddalene-Cattane\",\n        \"5\": \"Villaggio-Centro\",\n        \"7\": \"Laghetto-Stadio\"\n    };\n    return nomi[lineId] || `Linea ${lineId}`;\n}\n\nnode.log(`Calcolate statistiche per ${statistiche.length} linee`);\nreturn [statistiche];",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 80,
        "wires": [["split_line_stats"]]
    },
    {
        "id": "calc_system_stats",
        "type": "function",
        "z": "stats_tab",
        "name": "Calcola Statistiche Sistema",
        "func": "const now = new Date();\nconst allBuses = flow.get(\"buses\") || [];\n\nif (allBuses.length === 0) {\n    node.warn(\"Nessun dato autobus per statistiche sistema\");\n    return null;\n}\n\nconst totalBuses = 10;\nconst activeBuses = allBuses.length;\nconst totalPassengers = allBuses.reduce((sum, bus) => sum + bus.passengers, 0);\nconst averageSystemDelay = allBuses.reduce((sum, bus) => sum + bus.delay, 0) / allBuses.length;\n\nlet systemHealth;\nif (averageSystemDelay <= 1.0) {\n    systemHealth = \"EXCELLENT\";\n} else if (averageSystemDelay <= 2.0) {\n    systemHealth = \"GOOD\";\n} else if (averageSystemDelay <= 3.0) {\n    systemHealth = \"FAIR\";\n} else if (averageSystemDelay <= 5.0) {\n    systemHealth = \"POOR\";\n} else {\n    systemHealth = \"CRITICAL\";\n}\n\nconst averageSpeed = allBuses.reduce((sum, bus) => sum + bus.speed, 0) / allBuses.length;\n\nconst lineDistribution = {};\nallBuses.forEach(bus => {\n    lineDistribution[bus.line] = (lineDistribution[bus.line] || 0) + 1;\n});\n\nconst systemStats = {\n    total_buses: totalBuses,\n    active_buses: activeBuses,\n    total_passengers: totalPassengers,\n    average_system_delay: Math.round(averageSystemDelay * 10) / 10,\n    average_system_speed: Math.round(averageSpeed * 10) / 10,\n    system_health: systemHealth,\n    line_distribution: lineDistribution,\n    uptime_percentage: 95.0 + (Math.random() * 4),\n    timestamp: now.toISOString()\n};\n\nnode.log(`Statistiche Sistema: ${activeBuses}/${totalBuses} autobus, ${totalPassengers} passeggeri, ritardo medio ${averageSystemDelay.toFixed(1)}min`);\n\nreturn {\n    topic: \"vibus/sistema/generale/stato\",\n    payload: JSON.stringify(systemStats)\n};",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 140,
        "wires": [["mqtt_system_stats"]]
    },
    {
        "id": "split_line_stats",
        "type": "split",
        "z": "stats_tab",
        "name": "Split per Linea",
        "splt": "\\n",
        "spltType": "str",
        "arraySplt": 1,
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "x": 610,
        "y": 80,
        "wires": [["mqtt_line_stats"]]
    },
    {
        "id": "mqtt_line_stats",
        "type": "mqtt out",
        "z": "stats_tab",
        "name": "Pubblica MQTT Linee",
        "topic": "",
        "qos": "1",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker_stats",
        "x": 810,
        "y": 80,
        "wires": []
    },
    {
        "id": "mqtt_system_stats",
        "type": "mqtt out",
        "z": "stats_tab",
        "name": "Pubblica MQTT Sistema",
        "topic": "",
        "qos": "1",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker_stats",
        "x": 650,
        "y": 140,
        "wires": []
    },
    {
        "id": "debug_line_stats",
        "type": "debug",
        "z": "stats_tab",
        "name": "Debug Statistiche Linee",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 120,
        "wires": []
    },
    {
        "id": "debug_system_stats",
        "type": "debug",
        "z": "stats_tab",
        "name": "Debug Statistiche Sistema",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 180,
        "wires": []
    },
    {
        "id": "mqtt_broker_stats",
        "type": "mqtt-broker",
        "name": "Mosquitto Stats",
        "broker": "mosquitto",
        "port": "1883",
        "clientid": "nodered_stats",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "vibus/sistema/nodered/stato",
        "birthQos": "1",
        "birthRetain": "true",
        "birthPayload": "stats_online",
        "birthMsg": {},
        "closeTopic": "vibus/sistema/nodered/stato",
        "closeQos": "1",
        "closeRetain": "true",
        "closePayload": "stats_offline",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]